{"ast":null,"code":"var _jsxFileName = \"C:\\\\Users\\\\Gibi\\\\Documents\\\\IMT_CIENCIA_DA_COMPUTACAO\\\\PII\\\\Chatbot_Quantum\\\\ProjetoIntegrador2025\\\\src\\\\context\\\\ProgressContext.jsx\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\nimport AuthContext from './AuthContext';\n\n// Create Progress Context\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const ProgressContext = /*#__PURE__*/createContext();\nexport const ProgressProvider = ({\n  children\n}) => {\n  _s();\n  const {\n    currentUser\n  } = useContext(AuthContext);\n  const [userProgress, setUserProgress] = useState({});\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState(null);\n\n  // Load progress from localStorage on mount or when user changes\n  useEffect(() => {\n    if (currentUser) {\n      const storedProgress = localStorage.getItem(`quantum_progress_${currentUser.id}`);\n      if (storedProgress) {\n        setUserProgress(JSON.parse(storedProgress));\n      } else {\n        // Initialize empty progress for all 10 lessons\n        const initialProgress = {};\n        for (let i = 1; i <= 10; i++) {\n          initialProgress[i] = {\n            started: false,\n            completed: false,\n            interactions: 0,\n            lastActive: null,\n            conceptsExplored: [],\n            progressPercentage: 0\n          };\n        }\n        setUserProgress(initialProgress);\n        localStorage.setItem(`quantum_progress_${currentUser.id}`, JSON.stringify(initialProgress));\n      }\n    }\n  }, [currentUser]);\n\n  // Save progress to localStorage when it changes\n  useEffect(() => {\n    if (currentUser && Object.keys(userProgress).length > 0) {\n      localStorage.setItem(`quantum_progress_${currentUser.id}`, JSON.stringify(userProgress));\n    }\n  }, [userProgress, currentUser]);\n\n  // Update progress when user interacts with a lesson\n  const updateLessonProgress = useCallback((lessonId, interaction) => {\n    if (!currentUser) return;\n    setUserProgress(prev => {\n      const currentLessonProgress = prev[lessonId] || {\n        started: false,\n        completed: false,\n        interactions: 0,\n        lastActive: null,\n        conceptsExplored: [],\n        progressPercentage: 0\n      };\n\n      // Process the interaction type\n      let updatedProgress = {\n        ...currentLessonProgress\n      };\n      switch (interaction.type) {\n        case 'start':\n          updatedProgress.started = true;\n          updatedProgress.lastActive = new Date().toISOString();\n          break;\n        case 'message':\n          updatedProgress.interactions += 1;\n          updatedProgress.lastActive = new Date().toISOString();\n\n          // Check if the message contains any new concepts\n          if (interaction.concepts && interaction.concepts.length > 0) {\n            const newConcepts = interaction.concepts.filter(concept => !updatedProgress.conceptsExplored.includes(concept));\n            if (newConcepts.length > 0) {\n              updatedProgress.conceptsExplored = [...updatedProgress.conceptsExplored, ...newConcepts];\n            }\n          }\n\n          // Update progress percentage based on interactions and concepts\n          const maxInteractions = 20; // Arbitrary max for progress calculation\n          const interactionsProgress = Math.min(updatedProgress.interactions / maxInteractions, 0.7);\n          const conceptsProgress = updatedProgress.conceptsExplored.length > 0 ? updatedProgress.conceptsExplored.length / 5 * 0.3 // Assume 5 key concepts per lesson\n          : 0;\n          updatedProgress.progressPercentage = Math.min(Math.floor((interactionsProgress + conceptsProgress) * 100), 100);\n\n          // Mark as completed if progress is at 100%\n          if (updatedProgress.progressPercentage >= 100) {\n            updatedProgress.completed = true;\n          }\n          break;\n        case 'complete':\n          updatedProgress.completed = true;\n          updatedProgress.progressPercentage = 100;\n          updatedProgress.lastActive = new Date().toISOString();\n          break;\n        default:\n          break;\n      }\n      return {\n        ...prev,\n        [lessonId]: updatedProgress\n      };\n    });\n  }, [currentUser]);\n\n  // Get progress for a specific lesson\n  const getLessonProgress = useCallback(lessonId => {\n    return userProgress[lessonId] || {\n      started: false,\n      completed: false,\n      interactions: 0,\n      lastActive: null,\n      conceptsExplored: [],\n      progressPercentage: 0\n    };\n  }, [userProgress]);\n\n  // Get overall progress across all lessons\n  const getOverallProgress = useCallback(() => {\n    if (Object.keys(userProgress).length === 0) return 0;\n    const totalPercentage = Object.values(userProgress).reduce((sum, lesson) => sum + lesson.progressPercentage, 0);\n    return Math.floor(totalPercentage / 10); // 10 lessons\n  }, [userProgress]);\n\n  // Get completed lessons count\n  const getCompletedLessonsCount = useCallback(() => {\n    return Object.values(userProgress).filter(lesson => lesson.completed).length;\n  }, [userProgress]);\n\n  // Get started but not completed lessons\n  const getInProgressLessons = useCallback(() => {\n    return Object.entries(userProgress).filter(([_, lesson]) => lesson.started && !lesson.completed).map(([id, _]) => Number(id));\n  }, [userProgress]);\n\n  // Get all user progress data (for admin use)\n  const getAllUsersProgress = useCallback(async () => {\n    setLoading(true);\n    setError(null);\n    try {\n      // In a real app, this would be an API call to get all users' progress\n      // Simulating API call with timeout\n      await new Promise(resolve => setTimeout(resolve, 1000));\n\n      // Mock data for demo purposes\n      const mockUsers = [{\n        id: 'usr_1',\n        name: 'João Silva',\n        email: 'joao@example.com',\n        progress: {\n          overall: 65,\n          completedLessons: 4,\n          lastActive: '2025-04-13T14:30:00Z'\n        }\n      }, {\n        id: 'usr_2',\n        name: 'Maria Souza',\n        email: 'maria@example.com',\n        progress: {\n          overall: 42,\n          completedLessons: 2,\n          lastActive: '2025-04-12T09:15:00Z'\n        }\n      }, {\n        id: 'usr_3',\n        name: 'Pedro Santos',\n        email: 'pedro@example.com',\n        progress: {\n          overall: 90,\n          completedLessons: 8,\n          lastActive: '2025-04-14T10:45:00Z'\n        }\n      }];\n      return mockUsers;\n    } catch (err) {\n      setError(err.message || 'Erro ao buscar progresso dos usuários');\n      return [];\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n\n  // Context value\n  const value = {\n    userProgress,\n    loading,\n    error,\n    updateLessonProgress,\n    getLessonProgress,\n    getOverallProgress,\n    getCompletedLessonsCount,\n    getInProgressLessons,\n    getAllUsersProgress\n  };\n  return /*#__PURE__*/_jsxDEV(ProgressContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 228,\n    columnNumber: 5\n  }, this);\n};\n_s(ProgressProvider, \"5JKxaQfgn+CTMJZw+iA40vnL43A=\");\n_c = ProgressProvider;\nexport default ProgressContext;\nvar _c;\n$RefreshReg$(_c, \"ProgressProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","useContext","useCallback","AuthContext","jsxDEV","_jsxDEV","ProgressContext","ProgressProvider","children","_s","currentUser","userProgress","setUserProgress","loading","setLoading","error","setError","storedProgress","localStorage","getItem","id","JSON","parse","initialProgress","i","started","completed","interactions","lastActive","conceptsExplored","progressPercentage","setItem","stringify","Object","keys","length","updateLessonProgress","lessonId","interaction","prev","currentLessonProgress","updatedProgress","type","Date","toISOString","concepts","newConcepts","filter","concept","includes","maxInteractions","interactionsProgress","Math","min","conceptsProgress","floor","getLessonProgress","getOverallProgress","totalPercentage","values","reduce","sum","lesson","getCompletedLessonsCount","getInProgressLessons","entries","_","map","Number","getAllUsersProgress","Promise","resolve","setTimeout","mockUsers","name","email","progress","overall","completedLessons","err","message","value","Provider","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["C:/Users/Gibi/Documents/IMT_CIENCIA_DA_COMPUTACAO/PII/Chatbot_Quantum/ProjetoIntegrador2025/src/context/ProgressContext.jsx"],"sourcesContent":["import React, { createContext, useState, useEffect, useContext, useCallback } from 'react';\r\nimport AuthContext from './AuthContext';\r\n\r\n// Create Progress Context\r\nexport const ProgressContext = createContext();\r\n\r\nexport const ProgressProvider = ({ children }) => {\r\n  const { currentUser } = useContext(AuthContext);\r\n  const [userProgress, setUserProgress] = useState({});\r\n  const [loading, setLoading] = useState(false);\r\n  const [error, setError] = useState(null);\r\n\r\n  // Load progress from localStorage on mount or when user changes\r\n  useEffect(() => {\r\n    if (currentUser) {\r\n      const storedProgress = localStorage.getItem(`quantum_progress_${currentUser.id}`);\r\n      if (storedProgress) {\r\n        setUserProgress(JSON.parse(storedProgress));\r\n      } else {\r\n        // Initialize empty progress for all 10 lessons\r\n        const initialProgress = {};\r\n        for (let i = 1; i <= 10; i++) {\r\n          initialProgress[i] = {\r\n            started: false,\r\n            completed: false,\r\n            interactions: 0,\r\n            lastActive: null,\r\n            conceptsExplored: [],\r\n            progressPercentage: 0\r\n          };\r\n        }\r\n        setUserProgress(initialProgress);\r\n        localStorage.setItem(`quantum_progress_${currentUser.id}`, JSON.stringify(initialProgress));\r\n      }\r\n    }\r\n  }, [currentUser]);\r\n\r\n  // Save progress to localStorage when it changes\r\n  useEffect(() => {\r\n    if (currentUser && Object.keys(userProgress).length > 0) {\r\n      localStorage.setItem(\r\n        `quantum_progress_${currentUser.id}`,\r\n        JSON.stringify(userProgress)\r\n      );\r\n    }\r\n  }, [userProgress, currentUser]);\r\n\r\n  // Update progress when user interacts with a lesson\r\n  const updateLessonProgress = useCallback((lessonId, interaction) => {\r\n    if (!currentUser) return;\r\n    \r\n    setUserProgress(prev => {\r\n      const currentLessonProgress = prev[lessonId] || {\r\n        started: false,\r\n        completed: false,\r\n        interactions: 0,\r\n        lastActive: null,\r\n        conceptsExplored: [],\r\n        progressPercentage: 0\r\n      };\r\n      \r\n      // Process the interaction type\r\n      let updatedProgress = { ...currentLessonProgress };\r\n      \r\n      switch(interaction.type) {\r\n        case 'start':\r\n          updatedProgress.started = true;\r\n          updatedProgress.lastActive = new Date().toISOString();\r\n          break;\r\n          \r\n        case 'message':\r\n          updatedProgress.interactions += 1;\r\n          updatedProgress.lastActive = new Date().toISOString();\r\n          \r\n          // Check if the message contains any new concepts\r\n          if (interaction.concepts && interaction.concepts.length > 0) {\r\n            const newConcepts = interaction.concepts.filter(\r\n              concept => !updatedProgress.conceptsExplored.includes(concept)\r\n            );\r\n            \r\n            if (newConcepts.length > 0) {\r\n              updatedProgress.conceptsExplored = [\r\n                ...updatedProgress.conceptsExplored,\r\n                ...newConcepts\r\n              ];\r\n            }\r\n          }\r\n          \r\n          // Update progress percentage based on interactions and concepts\r\n          const maxInteractions = 20; // Arbitrary max for progress calculation\r\n          const interactionsProgress = Math.min(updatedProgress.interactions / maxInteractions, 0.7);\r\n          const conceptsProgress = updatedProgress.conceptsExplored.length > 0 \r\n            ? (updatedProgress.conceptsExplored.length / 5) * 0.3 // Assume 5 key concepts per lesson\r\n            : 0;\r\n            \r\n          updatedProgress.progressPercentage = Math.min(\r\n            Math.floor((interactionsProgress + conceptsProgress) * 100),\r\n            100\r\n          );\r\n          \r\n          // Mark as completed if progress is at 100%\r\n          if (updatedProgress.progressPercentage >= 100) {\r\n            updatedProgress.completed = true;\r\n          }\r\n          \r\n          break;\r\n          \r\n        case 'complete':\r\n          updatedProgress.completed = true;\r\n          updatedProgress.progressPercentage = 100;\r\n          updatedProgress.lastActive = new Date().toISOString();\r\n          break;\r\n          \r\n        default:\r\n          break;\r\n      }\r\n      \r\n      return {\r\n        ...prev,\r\n        [lessonId]: updatedProgress\r\n      };\r\n    });\r\n  }, [currentUser]);\r\n\r\n  // Get progress for a specific lesson\r\n  const getLessonProgress = useCallback((lessonId) => {\r\n    return userProgress[lessonId] || {\r\n      started: false,\r\n      completed: false,\r\n      interactions: 0,\r\n      lastActive: null,\r\n      conceptsExplored: [],\r\n      progressPercentage: 0\r\n    };\r\n  }, [userProgress]);\r\n\r\n  // Get overall progress across all lessons\r\n  const getOverallProgress = useCallback(() => {\r\n    if (Object.keys(userProgress).length === 0) return 0;\r\n    \r\n    const totalPercentage = Object.values(userProgress).reduce(\r\n      (sum, lesson) => sum + lesson.progressPercentage,\r\n      0\r\n    );\r\n    \r\n    return Math.floor(totalPercentage / 10); // 10 lessons\r\n  }, [userProgress]);\r\n\r\n  // Get completed lessons count\r\n  const getCompletedLessonsCount = useCallback(() => {\r\n    return Object.values(userProgress).filter(lesson => lesson.completed).length;\r\n  }, [userProgress]);\r\n\r\n  // Get started but not completed lessons\r\n  const getInProgressLessons = useCallback(() => {\r\n    return Object.entries(userProgress)\r\n      .filter(([_, lesson]) => lesson.started && !lesson.completed)\r\n      .map(([id, _]) => Number(id));\r\n  }, [userProgress]);\r\n\r\n  // Get all user progress data (for admin use)\r\n  const getAllUsersProgress = useCallback(async () => {\r\n    setLoading(true);\r\n    setError(null);\r\n    \r\n    try {\r\n      // In a real app, this would be an API call to get all users' progress\r\n      // Simulating API call with timeout\r\n      await new Promise(resolve => setTimeout(resolve, 1000));\r\n      \r\n      // Mock data for demo purposes\r\n      const mockUsers = [\r\n        {\r\n          id: 'usr_1',\r\n          name: 'João Silva',\r\n          email: 'joao@example.com',\r\n          progress: {\r\n            overall: 65,\r\n            completedLessons: 4,\r\n            lastActive: '2025-04-13T14:30:00Z'\r\n          }\r\n        },\r\n        {\r\n          id: 'usr_2',\r\n          name: 'Maria Souza',\r\n          email: 'maria@example.com',\r\n          progress: {\r\n            overall: 42,\r\n            completedLessons: 2,\r\n            lastActive: '2025-04-12T09:15:00Z'\r\n          }\r\n        },\r\n        {\r\n          id: 'usr_3',\r\n          name: 'Pedro Santos',\r\n          email: 'pedro@example.com',\r\n          progress: {\r\n            overall: 90,\r\n            completedLessons: 8,\r\n            lastActive: '2025-04-14T10:45:00Z'\r\n          }\r\n        }\r\n      ];\r\n      \r\n      return mockUsers;\r\n    } catch (err) {\r\n      setError(err.message || 'Erro ao buscar progresso dos usuários');\r\n      return [];\r\n    } finally {\r\n      setLoading(false);\r\n    }\r\n  }, []);\r\n\r\n  // Context value\r\n  const value = {\r\n    userProgress,\r\n    loading,\r\n    error,\r\n    updateLessonProgress,\r\n    getLessonProgress,\r\n    getOverallProgress,\r\n    getCompletedLessonsCount,\r\n    getInProgressLessons,\r\n    getAllUsersProgress\r\n  };\r\n\r\n  return (\r\n    <ProgressContext.Provider value={value}>\r\n      {children}\r\n    </ProgressContext.Provider>\r\n  );\r\n};\r\n\r\nexport default ProgressContext;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}